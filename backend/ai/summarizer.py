import os
from typing import List, Dict, Optional
from dotenv import load_dotenv

load_dotenv()

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "").strip()
GROQ_API_KEY = os.getenv("GROQ_API_KEY", "").strip()


# ─────────────────────────────────────────────────────────
# Rule-based fallbacks (no API key required)
# ─────────────────────────────────────────────────────────

def _rule_based_summary(domain: str, assets: List[Dict], risk_score: int, dist: Dict) -> str:
    high = dist.get("high", 0)
    medium = dist.get("medium", 0)
    low = dist.get("low", 0)
    total = len(assets)

    if risk_score >= 75:
        label = "CRITICAL"
    elif risk_score >= 50:
        label = "HIGH"
    elif risk_score >= 25:
        label = "MEDIUM"
    else:
        label = "LOW"

    risky_subs = [a["subdomain"] for a in assets if a["severity"] == "high"]
    risky_list = ", ".join(risky_subs[:3]) if risky_subs else "None identified"

    all_ports = [p for a in assets for p in a.get("ports", [])]
    has_db_ports = any(p in [3306, 5432, 27017, 6379] for p in all_ports)
    has_ssh = 22 in all_ports
    has_rdp = 3389 in all_ports

    findings = []
    if high > 0:
        findings.append(f"- **{high} high-severity** assets expose sensitive services or development environments publicly.")
    if has_db_ports:
        findings.append("- **Database ports detected** (MySQL/PostgreSQL/Redis/MongoDB) on external-facing subdomains — unauthorized access risk.")
    if has_ssh:
        findings.append("- **SSH (port 22) exposed** — brute-force and credential-stuffing attack surface identified.")
    if has_rdp:
        findings.append("- **RDP (port 3389) exposed** — high risk of ransomware pivot and lateral movement.")
    if not findings:
        findings.append("- No critical service exposures detected in current scan. Maintain regular monitoring.")

    findings_text = "\n".join(findings)

    return f"""## Executive Security Summary — {domain}

**Overall Risk Rating: {label} ({risk_score}/100)**

A reconnaissance scan of **{domain}** identified **{total} active subdomains** across the external attack surface. The analysis reveals **{high} high-severity**, **{medium} medium-severity**, and **{low} low-severity** assets.

### Key Findings
{findings_text}
- High-risk subdomains include: {risky_list}
- Total discoverable subdomains via public certificate transparency logs: {total}

### Recommendations
1. Immediately restrict access to high-severity subdomains behind VPN or firewall rules.
2. Audit and close unnecessary exposed service ports.
3. Implement subdomain monitoring to detect shadow IT and abandoned assets.
4. Enforce TLS/HTTPS across all discovered subdomains — redirect all HTTP traffic.
5. Enable MFA on all administrative interfaces and remote-access services.
6. Conduct quarterly penetration testing focused on high-risk assets.

*Generated by SentenalAI Threat Intelligence Engine | Risk Score: {risk_score}/100*"""


def _rule_based_narrative(domain: str, assets: List[Dict], risk_score: int) -> str:
    high_assets = [a for a in assets if a["severity"] == "high"]
    entry_point = high_assets[0]["subdomain"] if high_assets else (assets[0]["subdomain"] if assets else domain)
    exposed_ports = assets[0]["ports"] if assets else []

    ssh_line = "  > SSH (port 22) detected — initiating banner grab and credential spray..." if 22 in exposed_ports else ""
    db_line = "  > MySQL port 3306 exposed — attempting default credential access..." if 3306 in exposed_ports else ""
    dev_line = (
        f"  > Target '{entry_point}' appears to be a development/staging environment.\n"
        "  > Dev environments commonly have weaker auth, debug endpoints, and verbose error messages."
        if any(k in entry_point for k in ["dev", "test", "staging", "debug"])
        else "  > Production-facing asset — analysing WAF presence..."
    )

    feasibility = "HIGH" if risk_score >= 70 else "MEDIUM" if risk_score >= 40 else "LOW"
    eta = "< 2 hours" if risk_score >= 70 else "4–8 hours" if risk_score >= 40 else "> 24 hours"

    return f"""[ATTACKER SIMULATION — OSINT PHASE]

  Target acquired: {domain}
  Initiating passive reconnaissance via OSINT sources...

  > crt.sh: Discovered {len(assets)} subdomains via certificate transparency logs.
  > Shodan cross-reference: Checking for known CVEs on exposed IPs...
  > Selected primary entry point: {entry_point}
  > Discovered open ports: {', '.join(str(p) for p in exposed_ports)}

[ACTIVE RECONNAISSANCE]
{ssh_line}
{db_line}
{dev_line}
  > Enumerating HTTP endpoints on port 80/443...
  > Checking for exposed .git directories, robots.txt, and admin panels...

[CREDENTIAL & VULNERABILITY PHASE]

  > Searching GitHub/GitLab for hardcoded API keys or credentials matching {domain}...
  > Cross-referencing with HaveIBeenPwned breach data...
  > Checking for known CVEs against detected service versions...
  > Attempting common default credentials on administrative interfaces...

[IMPACT ASSESSMENT]

  Overall attack feasibility: {feasibility}
  Estimated time to initial foothold: {eta}
  Potential impact: {"Data exfiltration, lateral movement, full domain compromise." if risk_score >= 70 else "Limited access, service disruption possible." if risk_score >= 40 else "Low-impact, opportunistic access only."}

[END SIMULATION — This is a security assessment. No actual attack was performed.]"""


# ─────────────────────────────────────────────────────────
# Groq-powered generation (Secondary AI)
# ─────────────────────────────────────────────────────────

def _generate_via_groq(prompt: str) -> Optional[str]:
    """Helper to generate text via Groq API."""
    if not GROQ_API_KEY:
        return None
    try:
        from groq import Groq
        client = Groq(api_key=GROQ_API_KEY)
        chat_completion = client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model="llama-3.3-70b-versatile",
        )
        return chat_completion.choices[0].message.content
    except Exception as e:
        print(f"[WARN] Groq generation failed: {e}")
        return None


# ─────────────────────────────────────────────────────────
# Main generation entry points
# ─────────────────────────────────────────────────────────

def generate_summary(domain: str, assets: List[Dict], risk_score: int, dist: Dict) -> str:
    """Generate executive summary via Gemini, failing over to Groq, then rule-based."""
    asset_lines = []
    for a in assets[:10]:
        shodan = a.get("shodan_data", {})
        os_info = shodan.get("os", "Unknown OS")
        vulns = shodan.get("vulns", [])
        vuln_text = f" | Vulns: {len(vulns)}" if vulns else ""
        asset_lines.append(
            f"- {a['subdomain']} | IP: {a['ip']} | OS: {os_info} | Ports: {a['ports']}{vuln_text} | Risk: {a.get('risk_score', a.get('risk'))}"
        )
    
    formatted_assets = "\n".join(asset_lines)

    prompt = f"""You are a senior cybersecurity intelligence analyst. Generate a high-impact executive security summary.
    
Domain: {domain}
Overall Risk Score: {risk_score}/100
Severity Distribution: High={dist.get('high', 0)}, Medium={dist.get('medium', 0)}, Low={dist.get('low', 0)}

Analyzed Infrastructure:
{formatted_assets}

Instructions:
1. Provide a "Security Posture Analysis" section explaining WHY the score is {risk_score}.
2. Mention specific OS vulnerabilities or legacy systems found (e.g. if Shodan found old Windows versions).
3. Analyze "Attack Surface Exposure" based on the variety of open ports.
4. Provide 4-5 high-priority, actionable recommendations for a CISO.

Write the summary in professional markdown:
## Executive Security Summary — {domain}
- **Risk Rating**: [LEVEL] with emoji
- ### Posture Analysis
- ### Key Vulnerabilities
- ### Strategic Recommendations"""

    # 1. Try Gemini
    if GEMINI_API_KEY:
        try:
            import google.generativeai as genai
            genai.configure(api_key=GEMINI_API_KEY)
            model = genai.GenerativeModel("gemini-1.5-flash")
            response = model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"[WARN] Gemini summary failed: {e}")

    # 2. Try Groq
    groq_res = _generate_via_groq(prompt)
    if groq_res:
        return groq_res

    # 3. Fallback to rule-based
    return _rule_based_summary(domain, assets, risk_score, dist)


# ─────────────────────────────────────────────────────────
# Main generation entry points
# ─────────────────────────────────────────────────────────

def generate_attack_narrative(domain: str, assets: List[Dict], risk_score: int) -> str:
    """Generate red team attacker narrative via Gemini, failover to Groq, then rule-based."""
    high_assets = [a for a in assets if a["severity"] == "high"][:5]
    asset_details = []
    for a in high_assets:
        shodan = a.get("shodan_data", {})
        vulns = shodan.get("vulns", [])
        os_info = shodan.get("os", "Unknown")
        asset_details.append(
            f"- {a['subdomain']} ({os_info}): Ports {a['ports']} | CVEs: {', '.join(vulns[:3]) if vulns else 'None verified'}"
        )
    
    asset_info = "\n".join(asset_details) or "No high-severity assets identified."

    prompt = f"""You are an elite Red Team Lead conducting a black-box assessment. Write a realistic, terminal-style simulation log.

Target: {domain}
Exposure Level: {risk_score}/100
Critical Entry Points:
{asset_info}

Instructions:
1. Use a standard Red Team methodology: Recon -> Enumeration -> Exploitation -> Impact.
2. Structure the narrative as a "Reasoning Log" where you explain HOW you would chain vulnerabilities (e.g., "Using the legacy OS detected on {domain} as a pivot...").
3. Focus on lateral movement and data exfiltration feasibility.
4. Maintain a technical, "attacker mindset" tone.

Format:
[PHASE HEADER]
> reasoning_step 
> terminal_output

Always end with exactly: [END SIMULATION — This is a security assessment. No actual attack was performed.]"""

    # 1. Try Gemini
    if GEMINI_API_KEY:
        try:
            import google.generativeai as genai
            genai.configure(api_key=GEMINI_API_KEY)
            model = genai.GenerativeModel("gemini-1.5-flash")
            response = model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"[WARN] Gemini narrative failed: {e}")

    # 2. Try Groq
    groq_res = _generate_via_groq(prompt)
    if groq_res:
        return groq_res

    # 3. Fallback
    return _rule_based_narrative(domain, assets, risk_score)
